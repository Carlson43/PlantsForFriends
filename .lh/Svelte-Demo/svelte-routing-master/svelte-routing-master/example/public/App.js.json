{
    "sourceFile": "Svelte-Demo/svelte-routing-master/svelte-routing-master/example/public/App.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1642584803565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1642584812057,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,4 @@\n-import \"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js\"\n \n \n 'use strict';\n \n"
                },
                {
                    "date": 1642584919714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,4 @@\n-\n-\n 'use strict';\n \n function noop() { }\n function run(fn) {\n"
                }
            ],
            "date": 1642584803565,
            "name": "Commit-0",
            "content": "import \"https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js\"\n\n\n'use strict';\n\nfunction noop() { }\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nPromise.resolve();\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${style_object[key]};`)\n        .join(' ');\n}\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nconst LOCATION = {};\nconst ROUTER = {};\n\n/**\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js\n *\n * https://github.com/reach/router/blob/master/LICENSE\n * */\n\nfunction getLocation(source) {\n  return {\n    ...source.location,\n    state: source.history.state,\n    key: (source.history.state && source.history.state.key) || \"initial\"\n  };\n}\n\nfunction createHistory(source, options) {\n  const listeners = [];\n  let location = getLocation(source);\n\n  return {\n    get location() {\n      return location;\n    },\n\n    listen(listener) {\n      listeners.push(listener);\n\n      const popstateListener = () => {\n        location = getLocation(source);\n        listener({ location, action: \"POP\" });\n      };\n\n      source.addEventListener(\"popstate\", popstateListener);\n\n      return () => {\n        source.removeEventListener(\"popstate\", popstateListener);\n\n        const index = listeners.indexOf(listener);\n        listeners.splice(index, 1);\n      };\n    },\n\n    navigate(to, { state, replace = false } = {}) {\n      state = { ...state, key: Date.now() + \"\" };\n      // try...catch iOS Safari limits to 100 pushState calls\n      try {\n        if (replace) {\n          source.history.replaceState(state, null, to);\n        } else {\n          source.history.pushState(state, null, to);\n        }\n      } catch (e) {\n        source.location[replace ? \"replace\" : \"assign\"](to);\n      }\n\n      location = getLocation(source);\n      listeners.forEach(listener => listener({ location, action: \"PUSH\" }));\n    }\n  };\n}\n\n// Stores history entries in memory for testing or other platforms like Native\nfunction createMemorySource(initialPathname = \"/\") {\n  let index = 0;\n  const stack = [{ pathname: initialPathname, search: \"\" }];\n  const states = [];\n\n  return {\n    get location() {\n      return stack[index];\n    },\n    addEventListener(name, fn) {},\n    removeEventListener(name, fn) {},\n    history: {\n      get entries() {\n        return stack;\n      },\n      get index() {\n        return index;\n      },\n      get state() {\n        return states[index];\n      },\n      pushState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\");\n        index++;\n        stack.push({ pathname, search });\n        states.push(state);\n      },\n      replaceState(state, _, uri) {\n        const [pathname, search = \"\"] = uri.split(\"?\");\n        stack[index] = { pathname, search };\n        states[index] = state;\n      }\n    }\n  };\n}\n\n// Global history uses window.history as the source if available,\n// otherwise a memory history\nconst canUseDOM = Boolean(\n  typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n);\nconst globalHistory = createHistory(canUseDOM ? window : createMemorySource());\n\n/**\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js\n *\n * https://github.com/reach/router/blob/master/LICENSE\n * */\n\nconst paramRe = /^:(.+)/;\n\nconst SEGMENT_POINTS = 4;\nconst STATIC_POINTS = 3;\nconst DYNAMIC_POINTS = 2;\nconst SPLAT_PENALTY = 1;\nconst ROOT_POINTS = 1;\n\n/**\n * Check if `string` starts with `search`\n * @param {string} string\n * @param {string} search\n * @return {boolean}\n */\nfunction startsWith(string, search) {\n  return string.substr(0, search.length) === search;\n}\n\n/**\n * Check if `segment` is a root segment\n * @param {string} segment\n * @return {boolean}\n */\nfunction isRootSegment(segment) {\n  return segment === \"\";\n}\n\n/**\n * Check if `segment` is a dynamic segment\n * @param {string} segment\n * @return {boolean}\n */\nfunction isDynamic(segment) {\n  return paramRe.test(segment);\n}\n\n/**\n * Check if `segment` is a splat\n * @param {string} segment\n * @return {boolean}\n */\nfunction isSplat(segment) {\n  return segment[0] === \"*\";\n}\n\n/**\n * Split up the URI into segments delimited by `/`\n * @param {string} uri\n * @return {string[]}\n */\nfunction segmentize(uri) {\n  return (\n    uri\n      // Strip starting/ending `/`\n      .replace(/(^\\/+|\\/+$)/g, \"\")\n      .split(\"/\")\n  );\n}\n\n/**\n * Strip `str` of potential start and end `/`\n * @param {string} str\n * @return {string}\n */\nfunction stripSlashes(str) {\n  return str.replace(/(^\\/+|\\/+$)/g, \"\");\n}\n\n/**\n * Score a route depending on how its individual segments look\n * @param {object} route\n * @param {number} index\n * @return {object}\n */\nfunction rankRoute(route, index) {\n  const score = route.default\n    ? 0\n    : segmentize(route.path).reduce((score, segment) => {\n        score += SEGMENT_POINTS;\n\n        if (isRootSegment(segment)) {\n          score += ROOT_POINTS;\n        } else if (isDynamic(segment)) {\n          score += DYNAMIC_POINTS;\n        } else if (isSplat(segment)) {\n          score -= SEGMENT_POINTS + SPLAT_PENALTY;\n        } else {\n          score += STATIC_POINTS;\n        }\n\n        return score;\n      }, 0);\n\n  return { route, score, index };\n}\n\n/**\n * Give a score to all routes and sort them on that\n * @param {object[]} routes\n * @return {object[]}\n */\nfunction rankRoutes(routes) {\n  return (\n    routes\n      .map(rankRoute)\n      // If two routes have the exact same score, we go by index instead\n      .sort((a, b) =>\n        a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index\n      )\n  );\n}\n\n/**\n * Ranks and picks the best route to match. Each segment gets the highest\n * amount of points, then the type of segment gets an additional amount of\n * points where\n *\n *  static > dynamic > splat > root\n *\n * This way we don't have to worry about the order of our routes, let the\n * computers do it.\n *\n * A route looks like this\n *\n *  { path, default, value }\n *\n * And a returned match looks like:\n *\n *  { route, params, uri }\n *\n * @param {object[]} routes\n * @param {string} uri\n * @return {?object}\n */\nfunction pick(routes, uri) {\n  let match;\n  let default_;\n\n  const [uriPathname] = uri.split(\"?\");\n  const uriSegments = segmentize(uriPathname);\n  const isRootUri = uriSegments[0] === \"\";\n  const ranked = rankRoutes(routes);\n\n  for (let i = 0, l = ranked.length; i < l; i++) {\n    const route = ranked[i].route;\n    let missed = false;\n\n    if (route.default) {\n      default_ = {\n        route,\n        params: {},\n        uri\n      };\n      continue;\n    }\n\n    const routeSegments = segmentize(route.path);\n    const params = {};\n    const max = Math.max(uriSegments.length, routeSegments.length);\n    let index = 0;\n\n    for (; index < max; index++) {\n      const routeSegment = routeSegments[index];\n      const uriSegment = uriSegments[index];\n\n      if (routeSegment !== undefined && isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/* or /files/*splatname\n        const splatName = routeSegment === \"*\" ? \"*\" : routeSegment.slice(1);\n\n        params[splatName] = uriSegments\n          .slice(index)\n          .map(decodeURIComponent)\n          .join(\"/\");\n        break;\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true;\n        break;\n      }\n\n      let dynamicMatch = paramRe.exec(routeSegment);\n\n      if (dynamicMatch && !isRootUri) {\n        const value = decodeURIComponent(uriSegment);\n        params[dynamicMatch[1]] = value;\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true;\n        break;\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route,\n        params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\")\n      };\n      break;\n    }\n  }\n\n  return match || default_ || null;\n}\n\n/**\n * Check if the `path` matches the `uri`.\n * @param {string} path\n * @param {string} uri\n * @return {?object}\n */\nfunction match(route, uri) {\n  return pick([route], uri);\n}\n\n/**\n * Add the query to the pathname if a query is given\n * @param {string} pathname\n * @param {string} [query]\n * @return {string}\n */\nfunction addQuery(pathname, query) {\n  return pathname + (query ? `?${query}` : \"\");\n}\n\n/**\n * Resolve URIs as though every path is a directory, no files. Relative URIs\n * in the browser can feel awkward because not only can you be \"in a directory\",\n * you can be \"at a file\", too. For example:\n *\n *  browserSpecResolve('foo', '/bar/') => /bar/foo\n *  browserSpecResolve('foo', '/bar') => /foo\n *\n * But on the command line of a file system, it's not as complicated. You can't\n * `cd` from a file, only directories. This way, links have to know less about\n * their current path. To go deeper you can do this:\n *\n *  <Link to=\"deeper\"/>\n *  // instead of\n *  <Link to=`{${props.uri}/deeper}`/>\n *\n * Just like `cd`, if you want to go deeper from the command line, you do this:\n *\n *  cd deeper\n *  # not\n *  cd $(pwd)/deeper\n *\n * By treating every path as a directory, linking to relative paths should\n * require less contextual information and (fingers crossed) be more intuitive.\n * @param {string} to\n * @param {string} base\n * @return {string}\n */\nfunction resolve(to, base) {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to;\n  }\n\n  const [toPathname, toQuery] = to.split(\"?\");\n  const [basePathname] = base.split(\"?\");\n  const toSegments = segmentize(toPathname);\n  const baseSegments = segmentize(basePathname);\n\n  // ?a=b, /users?b=c => /users?a=b\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery);\n  }\n\n  // profile, /users/789 => /users/789/profile\n  if (!startsWith(toSegments[0], \".\")) {\n    const pathname = baseSegments.concat(toSegments).join(\"/\");\n\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n  }\n\n  // ./       , /users/123 => /users/123\n  // ../      , /users/123 => /users\n  // ../..    , /users/123 => /\n  // ../../one, /a/b/c/d   => /a/b/one\n  // .././one , /a/b/c/d   => /a/b/c/one\n  const allSegments = baseSegments.concat(toSegments);\n  const segments = [];\n\n  allSegments.forEach(segment => {\n    if (segment === \"..\") {\n      segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery);\n}\n\n/**\n * Combines the `basepath` and the `path` into one path.\n * @param {string} basepath\n * @param {string} path\n */\nfunction combinePaths(basepath, path) {\n  return `${stripSlashes(\n    path === \"/\" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`\n  )}/`;\n}\n\n/* node_modules\\svelte-routing\\src\\Router.svelte generated by Svelte v3.46.2 */\n\nconst Router = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\tlet $location, $$unsubscribe_location;\n\tlet $routes, $$unsubscribe_routes;\n\tlet $base, $$unsubscribe_base;\n\tlet { basepath = \"/\" } = $$props;\n\tlet { url = null } = $$props;\n\tconst locationContext = getContext(LOCATION);\n\tconst routerContext = getContext(ROUTER);\n\tconst routes = writable([]);\n\t$$unsubscribe_routes = subscribe(routes, value => $routes = value);\n\tconst activeRoute = writable(null);\n\tlet hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.\n\n\t// If locationContext is not set, this is the topmost Router in the tree.\n\t// If the `url` prop is given we force the location to it.\n\tconst location = locationContext || writable(url ? { pathname: url } : globalHistory.location);\n\n\t$$unsubscribe_location = subscribe(location, value => $location = value);\n\n\t// If routerContext is set, the routerBase of the parent Router\n\t// will be the base for this Router's descendants.\n\t// If routerContext is not set, the path and resolved uri will both\n\t// have the value of the basepath prop.\n\tconst base = routerContext\n\t? routerContext.routerBase\n\t: writable({ path: basepath, uri: basepath });\n\n\t$$unsubscribe_base = subscribe(base, value => $base = value);\n\n\tconst routerBase = derived([base, activeRoute], ([base, activeRoute]) => {\n\t\t// If there is no activeRoute, the routerBase will be identical to the base.\n\t\tif (activeRoute === null) {\n\t\t\treturn base;\n\t\t}\n\n\t\tconst { path: basepath } = base;\n\t\tconst { route, uri } = activeRoute;\n\n\t\t// Remove the potential /* or /*splatname from\n\t\t// the end of the child Routes relative paths.\n\t\tconst path = route.default\n\t\t? basepath\n\t\t: route.path.replace(/\\*.*$/, \"\");\n\n\t\treturn { path, uri };\n\t});\n\n\tfunction registerRoute(route) {\n\t\tconst { path: basepath } = $base;\n\t\tlet { path } = route;\n\n\t\t// We store the original path in the _path property so we can reuse\n\t\t// it when the basepath changes. The only thing that matters is that\n\t\t// the route reference is intact, so mutation is fine.\n\t\troute._path = path;\n\n\t\troute.path = combinePaths(basepath, path);\n\n\t\tif (typeof window === \"undefined\") {\n\t\t\t// In SSR we should set the activeRoute immediately if it is a match.\n\t\t\t// If there are more Routes being registered after a match is found,\n\t\t\t// we just skip them.\n\t\t\tif (hasActiveRoute) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst matchingRoute = match(route, $location.pathname);\n\n\t\t\tif (matchingRoute) {\n\t\t\t\tactiveRoute.set(matchingRoute);\n\t\t\t\thasActiveRoute = true;\n\t\t\t}\n\t\t} else {\n\t\t\troutes.update(rs => {\n\t\t\t\trs.push(route);\n\t\t\t\treturn rs;\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction unregisterRoute(route) {\n\t\troutes.update(rs => {\n\t\t\tconst index = rs.indexOf(route);\n\t\t\trs.splice(index, 1);\n\t\t\treturn rs;\n\t\t});\n\t}\n\n\tif (!locationContext) {\n\t\t// The topmost Router in the tree is responsible for updating\n\t\t// the location store and supplying it through context.\n\t\tonMount(() => {\n\t\t\tconst unlisten = globalHistory.listen(history => {\n\t\t\t\tlocation.set(history.location);\n\t\t\t});\n\n\t\t\treturn unlisten;\n\t\t});\n\n\t\tsetContext(LOCATION, location);\n\t}\n\n\tsetContext(ROUTER, {\n\t\tactiveRoute,\n\t\tbase,\n\t\trouterBase,\n\t\tregisterRoute,\n\t\tunregisterRoute\n\t});\n\n\tif ($$props.basepath === void 0 && $$bindings.basepath && basepath !== void 0) $$bindings.basepath(basepath);\n\tif ($$props.url === void 0 && $$bindings.url && url !== void 0) $$bindings.url(url);\n\n\t{\n\t\t{\n\t\t\tconst { path: basepath } = $base;\n\n\t\t\troutes.update(rs => {\n\t\t\t\trs.forEach(r => r.path = combinePaths(basepath, r._path));\n\t\t\t\treturn rs;\n\t\t\t});\n\t\t}\n\t}\n\n\t{\n\t\t{\n\t\t\tconst bestMatch = pick($routes, $location.pathname);\n\t\t\tactiveRoute.set(bestMatch);\n\t\t}\n\t}\n\n\t$$unsubscribe_location();\n\t$$unsubscribe_routes();\n\t$$unsubscribe_base();\n\treturn `${slots.default ? slots.default({}) : ``}`;\n});\n\n/* node_modules\\svelte-routing\\src\\Route.svelte generated by Svelte v3.46.2 */\n\nconst Route = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\tlet $activeRoute, $$unsubscribe_activeRoute;\n\tlet $location, $$unsubscribe_location;\n\tlet { path = \"\" } = $$props;\n\tlet { component = null } = $$props;\n\tconst { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);\n\t$$unsubscribe_activeRoute = subscribe(activeRoute, value => $activeRoute = value);\n\tconst location = getContext(LOCATION);\n\t$$unsubscribe_location = subscribe(location, value => $location = value);\n\n\tconst route = {\n\t\tpath,\n\t\t// If no path prop is given, this Route will act as the default Route\n\t\t// that is rendered if no other Route in the Router is a match.\n\t\tdefault: path === \"\"\n\t};\n\n\tlet routeParams = {};\n\tlet routeProps = {};\n\tregisterRoute(route);\n\n\t// There is no need to unregister Routes in SSR since it will all be\n\t// thrown away anyway.\n\tif (typeof window !== \"undefined\") {\n\t\tonDestroy(() => {\n\t\t\tunregisterRoute(route);\n\t\t});\n\t}\n\n\tif ($$props.path === void 0 && $$bindings.path && path !== void 0) $$bindings.path(path);\n\tif ($$props.component === void 0 && $$bindings.component && component !== void 0) $$bindings.component(component);\n\n\t{\n\t\tif ($activeRoute && $activeRoute.route === route) {\n\t\t\trouteParams = $activeRoute.params;\n\t\t}\n\t}\n\n\t{\n\t\t{\n\t\t\tconst { path, component, ...rest } = $$props;\n\t\t\trouteProps = rest;\n\t\t}\n\t}\n\n\t$$unsubscribe_activeRoute();\n\t$$unsubscribe_location();\n\n\treturn `${$activeRoute !== null && $activeRoute.route === route\n\t? `${component !== null\n\t\t? `${validate_component(component || missing_component, \"svelte:component\").$$render($$result, Object.assign({ location: $location }, routeParams, routeProps), {}, {})}`\n\t\t: `${slots.default\n\t\t\t? slots.default({ params: routeParams, location: $location })\n\t\t\t: ``}`}`\n\t: ``}`;\n});\n\n/* node_modules\\svelte-routing\\src\\Link.svelte generated by Svelte v3.46.2 */\n\nconst Link = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\tlet ariaCurrent;\n\tlet $$restProps = compute_rest_props($$props, [\"to\",\"replace\",\"state\",\"getProps\"]);\n\tlet $location, $$unsubscribe_location;\n\tlet $base, $$unsubscribe_base;\n\tlet { to = \"#\" } = $$props;\n\tlet { replace = false } = $$props;\n\tlet { state = {} } = $$props;\n\tlet { getProps = () => ({}) } = $$props;\n\tconst { base } = getContext(ROUTER);\n\t$$unsubscribe_base = subscribe(base, value => $base = value);\n\tconst location = getContext(LOCATION);\n\t$$unsubscribe_location = subscribe(location, value => $location = value);\n\tcreateEventDispatcher();\n\tlet href, isPartiallyCurrent, isCurrent, props;\n\n\tif ($$props.to === void 0 && $$bindings.to && to !== void 0) $$bindings.to(to);\n\tif ($$props.replace === void 0 && $$bindings.replace && replace !== void 0) $$bindings.replace(replace);\n\tif ($$props.state === void 0 && $$bindings.state && state !== void 0) $$bindings.state(state);\n\tif ($$props.getProps === void 0 && $$bindings.getProps && getProps !== void 0) $$bindings.getProps(getProps);\n\thref = to === \"/\" ? $base.uri : resolve(to, $base.uri);\n\tisPartiallyCurrent = startsWith($location.pathname, href);\n\tisCurrent = href === $location.pathname;\n\tariaCurrent = isCurrent ? \"page\" : undefined;\n\n\tprops = getProps({\n\t\tlocation: $location,\n\t\thref,\n\t\tisPartiallyCurrent,\n\t\tisCurrent\n\t});\n\n\t$$unsubscribe_location();\n\t$$unsubscribe_base();\n\n\treturn `<a${spread(\n\t\t[\n\t\t\t{ href: escape_attribute_value(href) },\n\t\t\t{\n\t\t\t\t\"aria-current\": escape_attribute_value(ariaCurrent)\n\t\t\t},\n\t\t\tescape_object(props),\n\t\t\tescape_object($$restProps)\n\t\t],\n\t\t{}\n\t)}>${slots.default ? slots.default({}) : ``}</a>`;\n});\n\n/* src\\components\\NavLink.svelte generated by Svelte v3.46.2 */\n\nfunction getProps({ location, href, isPartiallyCurrent, isCurrent }) {\n\tconst isActive = href === \"/\"\n\t? isCurrent\n\t: isPartiallyCurrent || isCurrent;\n\n\t// The object returned here is spread on the anchor element's attributes\n\tif (isActive) {\n\t\treturn { class: \"active\" };\n\t}\n\n\treturn {};\n}\n\nconst NavLink = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\tlet { to = \"\" } = $$props;\n\tif ($$props.to === void 0 && $$bindings.to && to !== void 0) $$bindings.to(to);\n\n\treturn `${validate_component(Link, \"Link\").$$render($$result, { to, getProps }, {}, {\n\t\tdefault: () => {\n\t\t\treturn `${slots.default ? slots.default({}) : ``}`;\n\t\t}\n\t})}`;\n});\n\n/* src\\components\\Navbar.svelte generated by Svelte v3.46.2 */\n\nconst Navbar = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\treturn `\n<nav class=\"${\"navbar navbar-expand-lg navbar-light bg-light\"}\"><div class=\"${\"container fluid\"}\">\n        <a class=\"${\"navbar-brand\"}\" href=\"${\"index.html\"}\"><img src=\"${\"./icons/logo.svg\"}\" alt=\"${\"\"}\" width=\"${\"30\"}\" height=\"${\"24\"}\" class=\"${\"d-inline-block align-text-top\"}\">\n            Plants4Friends\n        </a>\n        \n        <button class=\"${\"navbar-toggler\"}\" type=\"${\"button\"}\" data-bs-toggle=\"${\"collapse\"}\" data-bs-target=\"${\"#navbarNav\"}\" aria-controls=\"${\"navbarNav\"}\" aria-expanded=\"${\"false\"}\" aria-label=\"${\"Toggle navigation\"}\"><span class=\"${\"navbar-toggler-icon\"}\"></span></button>\n        \n        <div class=\"${\"collapse navbar-collapse\"}\" id=\"${\"navbarNav\"}\"><div class=\"${\"navbar-nav\"}\"><a class=\"${\"nav-link\"}\" href=\"${\"#\"}\">Home</a>\n                <a class=\"${\"nav-link\"}\" href=\"${\"#\"}\">Anzeige erstellen</a>\n                <a class=\"${\"nav-link\"}\" href=\"${\"#\"}\">Karte</a></div></div></div></nav>`;\n});\n\n/* src\\routes\\Home.svelte generated by Svelte v3.46.2 */\n\nconst Home = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\treturn `<h1>Home</h1>\n<p>Welcome to my website</p>\n\n${validate_component(Navbar, \"Navbar\").$$render($$result, {}, {}, {})}`;\n});\n\n/* src\\routes\\About.svelte generated by Svelte v3.46.2 */\n\nconst About = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\treturn `<h1>About</h1>\n<p>I like to code</p>`;\n});\n\n/* src\\routes\\Blog.svelte generated by Svelte v3.46.2 */\n\nconst Blog = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\treturn `${validate_component(Router, \"Router\").$$render($$result, {}, {}, {\n\t\tdefault: () => {\n\t\t\treturn `<h1>Blog</h1>\n\n  <ul><li>${validate_component(Link, \"Link\").$$render($$result, { to: \"first\" }, {}, {\n\t\t\t\tdefault: () => {\n\t\t\t\t\treturn `Today I did something cool`;\n\t\t\t\t}\n\t\t\t})}</li>\n    <li>${validate_component(Link, \"Link\").$$render($$result, { to: \"second\" }, {}, {\n\t\t\t\tdefault: () => {\n\t\t\t\t\treturn `I did something awesome today`;\n\t\t\t\t}\n\t\t\t})}</li>\n    <li>${validate_component(Link, \"Link\").$$render($$result, { to: \"third\" }, {}, {\n\t\t\t\tdefault: () => {\n\t\t\t\t\treturn `Did something sweet today`;\n\t\t\t\t}\n\t\t\t})}</li></ul>\n\n  ${validate_component(Route, \"Route\").$$render($$result, { path: \"first\" }, {}, {\n\t\t\t\tdefault: () => {\n\t\t\t\t\treturn `<p>I did something cool today. Lorem ipsum dolor sit amet, consectetur \n      adipisicing elit. Quisquam rerum asperiores, ex animi sunt ipsum. Voluptas \n      sint id hic. Vel neque maxime exercitationem facere culpa nisi, nihil \n      incidunt quo nostrum, beatae dignissimos dolores natus quaerat! Quasi sint \n      praesentium inventore quidem, deserunt atque ipsum similique dolores maiores\n      expedita, qui totam. Totam et incidunt assumenda quas explicabo corporis \n      eligendi amet sint ducimus, culpa fugit esse. Tempore dolorum sit \n      perspiciatis corporis molestias nemo, veritatis, asperiores earum! \n      Ex repudiandae aperiam asperiores esse minus veniam sapiente corrupti \n      alias deleniti excepturi saepe explicabo eveniet harum fuga numquam \n      nostrum adipisci pariatur iusto sint, impedit provident repellat quis?\n    </p>`;\n\t\t\t\t}\n\t\t\t})}\n  ${validate_component(Route, \"Route\").$$render($$result, { path: \"second\" }, {}, {\n\t\t\t\tdefault: () => {\n\t\t\t\t\treturn `<p>I did something awesome today. Lorem ipsum dolor sit amet, consectetur \n      adipisicing elit. Repudiandae enim quasi animi, vero deleniti dignissimos \n      sapiente perspiciatis. Veniam, repellendus, maiores.\n    </p>`;\n\t\t\t\t}\n\t\t\t})}\n  ${validate_component(Route, \"Route\").$$render($$result, { path: \"third\" }, {}, {\n\t\t\t\tdefault: () => {\n\t\t\t\t\treturn `<p>I did something sweet today. Lorem ipsum dolor sit amet, consectetur \n      adipisicing elit. Modi ad voluptas rem consequatur commodi minima doloribus \n      veritatis nam, quas, culpa autem repellat saepe quam deleniti maxime delectus \n      fuga totam libero sit neque illo! Sapiente consequatur rem minima expedita \n      nemo blanditiis, aut veritatis alias nostrum vel? Esse molestias placeat, \n      doloribus commodi.\n    </p>`;\n\t\t\t\t}\n\t\t\t})}`;\n\t\t}\n\t})}`;\n});\n\n/* src\\App.svelte generated by Svelte v3.46.2 */\n\nconst App = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\tlet { url = \"\" } = $$props;\n\tif ($$props.url === void 0 && $$bindings.url && url !== void 0) $$bindings.url(url);\n\n\treturn `${validate_component(Router, \"Router\").$$render($$result, { url }, {}, {\n\t\tdefault: () => {\n\t\t\treturn `<nav>${validate_component(NavLink, \"NavLink\").$$render($$result, { to: \"/\" }, {}, {\n\t\t\t\tdefault: () => {\n\t\t\t\t\treturn `Home`;\n\t\t\t\t}\n\t\t\t})}\n    ${validate_component(NavLink, \"NavLink\").$$render($$result, { to: \"about\" }, {}, {\n\t\t\t\tdefault: () => {\n\t\t\t\t\treturn `About`;\n\t\t\t\t}\n\t\t\t})}\n    ${validate_component(NavLink, \"NavLink\").$$render($$result, { to: \"blog\" }, {}, {\n\t\t\t\tdefault: () => {\n\t\t\t\t\treturn `Blog`;\n\t\t\t\t}\n\t\t\t})}</nav>\n  <div>${validate_component(Route, \"Route\").$$render($$result, { path: \"about\", component: About }, {}, {})}\n    ${validate_component(Route, \"Route\").$$render($$result, { path: \"blog/*\", component: Blog }, {}, {})}\n    ${validate_component(Route, \"Route\").$$render($$result, { path: \"/\", component: Home }, {}, {})}</div>`;\n\t\t}\n\t})}`;\n});\n\nmodule.exports = App;\n"
        }
    ]
}